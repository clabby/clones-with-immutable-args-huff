/// @notice Reads an immutable arg with type address
/// @param argOffset The offset of the arg in the packed data
/// @return arg The arg value
#define macro GET_ARG_ADDRESS() = takes (1) returns (1) {
    // Initial Stack: // [argOffset]
    GET_IMMUTABLE_ARGS_OFFSET() // [offset, argOffset]
    add               // [offset + argOffset]
    calldataload      // [cd]
    0x60              // [0x60, cd]
    shr               // [cd >> 0x60]
}

/// @notice Reads an immutable arg with type uint256
/// @param argOffset The offset of the arg in the packed data
/// @return arg The arg value
#define macro GET_ARG_UINT_256() = takes (1) returns (1) {
    // Initial Stack: // [argOffset]
    GET_IMMUTABLE_ARGS_OFFSET() // [offset, argOffset]
    add               // [offset + argOffset]
    calldataload      // [cd]
}

/// @notice Reads a uint256 array stored in the immutable args.
/// @param argOffset The offset of the arg in the packed data
/// @param arrLen Number of elements in the array
/// @return arr The array
// TODO: Finish
#define macro GET_ARG_UINT_256_ARR() = takes (2) returns (1) {
    // Initial Stack: // [argOffset, arrLen]
    GET_IMMUTABLE_ARGS_OFFSET() // [offset, argOffset, arrLen]

    0x00 0x00 mstore  // [offset, argOffset, arrLen]
    loop_body:
        0x00 mload    // [loop_index, offset, argOffset, arrLen] 
        
        // Check if loop is complete
        dup4          // [arrLen, loop_index, offset, argOffset, arrLen] 
        dup2          // [loop_index, arrLen, loop_index, offset, argOffset, arrLen]
        gt            // [loop_index > arrLen, loop_index, offset, argOffset, arrLen]
        dup5          // [arrLen, loop_index > arrLen, loop_index, offset, argOffset, arrLen]
        dup3          // [loop_index, arrLen, loop_index > arrLen, loop_index, offset, argOffset, arrLen]
        eq            // [loop_index == arrLen, loop_index > arrLen, loop_index, offset, argOffset, arrLen]
        or            // [loop_index == arrLen | loop_index > arrLen, loop_index, offset, argOffset, arrLen]
        finish jumpi  // If the loop index is >= to the array index, exit it.

        0x20          // [0x20, loop_index, offset, argOffset, arrLen]
        mul           // [0x20 * loop_index, offset, argOffset, arrLen]

        dup2          // [offset, 0x20 * loop_index, offset, argOffset, arrLen]
        dup4          // [argOffset, offset, 0x20 * loop_index, offset, argOffset, arrLen]
        add           // [argOffset + offset, 0x20 * loop_index, offset, argOffset, arrLen]
        add           // [argOffset + offset + 0x20 * loop_index, offset, argOffset, arrLen]
        calldataload  // [cd, offset, argOffset, arrLen]

        // Store calldata in array

        // Increment loop
        0x00 mload
        0x01
        add
        0x00 mstore
    finish:
        // ...
}

/// @notice Reads an immutable arg with type uint64
/// @param argOffset The offset of the arg in the packed data
/// @return arg The arg value
#define macro GET_ARG_UINT_64() = takes (1) returns (1) {
    // Initial Stack: // [argOffset]
    GET_IMMUTABLE_ARGS_OFFSET() // [offset, argOffset]
    add               // [offset + argOffset]
    calldataload      // [cd]
    0xC0              // [0xC0, cd]
    shr               // [cd >> 0xC0]
}

/// @notice Reads an immutable arg with type uint8
/// @param argOffset The offset of the arg in the packed data
/// @return The arg value
#define macro GET_ARG_UINT_8() = takes (1) returns (1) {
    // Initial Stack: // [argOffset]
    GET_IMMUTABLE_ARGS_OFFSET() // [offset, argOffset]
    add               // [offset + argOffset]
    calldataload      // [cd]
    0xF8              // [0xF8, cd]
    shr               // [cd >> 0xF8]
}

/// @return The offset of the packed immutable args in calldata
#define macro GET_IMMUTABLE_ARGS_OFFSET() = takes (0) returns (1) {
    0x02              // [0x02]
    calldatasize      // [calldatasize, 0x02]
    sub               // [calldatasize - 0x02]

    calldataload      // [cd]
    0xF0              // [0xF0, cd]
    shr               // [cd >> 0xF0]

    0x02              // [0x02, cd >> 0xF0]
    add               // [0x02 + cd >> 0xF0]

    calldatasize      // [calldatasize, 0x02 + cd >> 0xF0]
    sub               // [calldatasize - (0x02 + cd >> 0xF0)]
}