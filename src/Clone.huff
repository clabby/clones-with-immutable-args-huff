/// @notice Reads an immutable arg with type address
/// @param argOffset The offset of the arg in the packed data
/// @return arg The arg value
#define macro GET_ARG_ADDRESS() = takes (1) returns (1) {
    // Initial Stack: // [argOffset]
    GET_IMMUTABLE_ARGS_OFFSET() // [offset, argOffset]
    add               // [offset + argOffset]
    calldataload      // [cd]
    0x60              // [0x60, cd]
    shr               // [cd >> 0x60]
}

/// @notice Reads an immutable arg with type uint256
/// @param argOffset The offset of the arg in the packed data
/// @return arg The arg value
#define macro GET_ARG_UINT_256() = takes (1) returns (1) {
    // Initial Stack: // [argOffset]
    GET_IMMUTABLE_ARGS_OFFSET() // [offset, argOffset]
    add               // [offset + argOffset]
    calldataload      // [cd]
}

/// @notice Reads a uint256 array stored in the immutable args.
/// @param argOffset The offset of the arg in the packed data
/// @param arrLen Number of elements in the array
/// @return arr The beginning location of the array in memory
// TODO: Optimize
#define macro GET_ARG_UINT_256_ARR() = takes (2) returns (1) {
    // Initial Stack: // [argOffset, arrLen]
    GET_IMMUTABLE_ARGS_OFFSET() // [offset, argOffset, arrLen]

    0x00 0x00 mstore  // [offset, argOffset, arrLen]
    // Write array length to memory at slot 0x20
    dup3 0x20 mstore  // [offset, argOffset, arrLen]
    loop_body:
        0x00 mload    // [loop_index, offset, argOffset, arrLen] 
        
        // Check if loop is complete
        dup4          // [arrLen, loop_index, offset, argOffset, arrLen] 
        dup2          // [loop_index, arrLen, loop_index, offset, argOffset, arrLen]
        gt            // [loop_index > arrLen, loop_index, offset, argOffset, arrLen]
        dup5          // [arrLen, loop_index > arrLen, loop_index, offset, argOffset, arrLen]
        dup3          // [loop_index, arrLen, loop_index > arrLen, loop_index, offset, argOffset, arrLen]
        eq            // [loop_index == arrLen, loop_index > arrLen, loop_index, offset, argOffset, arrLen]
        or            // [loop_index == arrLen | loop_index > arrLen, loop_index, offset, argOffset, arrLen]
        finish jumpi  // If the loop index is >= to the array index, the loop is complete.

        0x20          // [0x20, loop_index, offset, argOffset, arrLen]
        mul           // [0x20 * loop_index, offset, argOffset, arrLen]

        // Load array element from calldata
        dup2          // [offset, 0x20 * loop_index, offset, argOffset, arrLen]
        dup4          // [argOffset, offset, 0x20 * loop_index, offset, argOffset, arrLen]
        add           // [argOffset + offset, 0x20 * loop_index, offset, argOffset, arrLen]
        add           // [argOffset + offset + 0x20 * loop_index, offset, argOffset, arrLen]
        calldataload  // [cd, offset, argOffset, arrLen]

        // Store element at next 32 byte offset in memory
        // ((loop_index + 1) * 0x20) + 0x20
        // nasty rn
        0x00 mload    // [loop_index, cd, offset, argOffset, arrLen]
        dup1          // [loop_index, loop_index, cd, offset, argOffset, arrLen]
        0x01 add      // [loop_index + 1, loop_index, cd, offset, argOffset, arrLen]
        0x20 mul      // [(loop_index + 1) * 0x20, loop_index, cd, offset, argOffset, arrLen]
        0x20 add      // [((loop_index + 1) * 0x20) + 0x20, loop_index, cd, offset, argOffset, arrLen]
        swap2         // [cd, ((loop_index + 1) * 0x20) + 0x20, loop_index, offset, argOffset, arrLen]
        swap1         // [((loop_index + 1) * 0x20) + 0x20, cd, loop_index, offset, argOffset, arrLen]
        mstore        // [loop_index, offset, argOffset, arrLen]

        0x01          // [0x01, loop_index, offset, argOffset, arrLen]
        add           // [0x01 + loop_index, offset, argOffset, arrLen]
        0x00 mstore   // [offset, argOffset, arrLen]

        0x01 loop_body jumpi
    finish:
        pop pop pop   // [] - Clear the stack
        0x20          // [0x20] - Beginning location of the array in memory
}

/// @notice Reads an immutable arg with type uint64
/// @param argOffset The offset of the arg in the packed data
/// @return arg The arg value
#define macro GET_ARG_UINT_64() = takes (1) returns (1) {
    // Initial Stack: // [argOffset]
    GET_IMMUTABLE_ARGS_OFFSET() // [offset, argOffset]
    add               // [offset + argOffset]
    calldataload      // [cd]
    0xC0              // [0xC0, cd]
    shr               // [cd >> 0xC0]
}

/// @notice Reads an immutable arg with type uint8
/// @param argOffset The offset of the arg in the packed data
/// @return The arg value
#define macro GET_ARG_UINT_8() = takes (1) returns (1) {
    // Initial Stack: // [argOffset]
    GET_IMMUTABLE_ARGS_OFFSET() // [offset, argOffset]
    add               // [offset + argOffset]
    calldataload      // [cd]
    0xF8              // [0xF8, cd]
    shr               // [cd >> 0xF8]
}

/// @return The offset of the packed immutable args in calldata
#define macro GET_IMMUTABLE_ARGS_OFFSET() = takes (0) returns (1) {
    0x02              // [0x02]
    calldatasize      // [calldatasize, 0x02]
    sub               // [calldatasize - 0x02]

    calldataload      // [cd]
    0xF0              // [0xF0, cd]
    shr               // [cd >> 0xF0]

    0x02              // [0x02, cd >> 0xF0]
    add               // [0x02 + cd >> 0xF0]

    calldatasize      // [calldatasize, 0x02 + cd >> 0xF0]
    sub               // [calldatasize - (0x02 + cd >> 0xF0)]
}